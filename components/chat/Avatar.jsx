/*

Auto - generated by: https://github.com/pmndrs/gltfjsx
Command: npx gltfjsx @6.2.3 public / models / 64f1a714fe61576b46f27ca2.glb - o src / components / Avatar.jsx - k - r public
  */

import { useAnimations, useGLTF } from "@react-three/drei";
import { useFrame } from "@react-three/fiber";
import { button, useControls } from "leva";
import React, { useEffect, useRef, useState, useCallback, useContext, useMemo, } from "react"; // 1. useContext Ø§ÛŒÙ†Ø¬Ø§Ø³Øª
import * as THREE from "three";



import { ChatbotUIContext } from "@/context/context";


// Ù‡Ù…Ú¯Ø§Ù…â€ŒØ³Ø§Ø²ÛŒ Ù…ÙˆÙ‚Ø¹ÛŒØª
const preserveBonePositions = () => {
  group.current.children.forEach((child) => {
    if (child.isSkinnedMesh && child.skeleton) {
      child.skeleton.bones.forEach((bone) => {
        bone.userData.previousPosition = bone.position.clone();
        bone.userData.previousQuaternion = bone.quaternion.clone();
      });
    }
  });
};

const restoreBonePositions = () => {
  group.current.children.forEach((child) => {
    if (child.isSkinnedMesh && child.skeleton) {
      child.skeleton.bones.forEach((bone) => {
        if (bone.userData.previousPosition && bone.userData.previousQuaternion) {
          bone.position.copy(bone.userData.previousPosition);
          bone.quaternion.copy(bone.userData.previousQuaternion);
        }
      });
    }
  });
};


const facialExpressions = {
  default: {},
  smile: {
    browInnerUp: 0.16999999650706504,
    mouthPressLeft: 0.61,
    mouthPressRight: 0.63,
    mouthSmileLeft: 0.2,
    mouthSmileRight: 0.2

  },
  funnyFace: {
    jawLeft: 0.63,
    mouthPucker: 0.53,
    noseSneerLeft: 1,
    noseSneerRight: 0.39,
    mouthLeft: 1,
    eyeLookUpLeft: 1,
    eyeLookUpRight: 1,
    cheekPuff: 0.9999924982764238,
    mouthDimpleLeft: 0.414743888682652,
    mouthRollLower: 0.32,
    mouthSmileLeft: 0.35499733688813034,
    mouthSmileRight: 0.35499733688813034,
  },
  sad: {
    mouthFrownLeft: 1,
    mouthFrownRight: 1,
    mouthShrugLower: 0.78341,
    browInnerUp: 0.452,
    eyeSquintLeft: 0.72,
    eyeSquintRight: 0.75,
    eyeLookDownLeft: 0.5,
    eyeLookDownRight: 0.5,
    jawForward: 1,
  },
  surprised: {
    eyeWideLeft: 0.5,
    eyeWideRight: 0.5,
    jawOpen: 0.351,
    mouthFunnel: 1,
    browInnerUp: 1,
  },
  angry: {
    browDownLeft: 1,
    browDownRight: 1,
    eyeSquintLeft: 1,
    eyeSquintRight: 1,
    jawForward: 1,
    jawLeft: 1,
    mouthShrugLower: 1,
    noseSneerLeft: 1,
    noseSneerRight: 0.42,
    eyeLookDownLeft: 0.16,
    eyeLookDownRight: 0.16,
    cheekSquintLeft: 1,
    cheekSquintRight: 1,
    mouthClose: 0.23,
    mouthFunnel: 0.63,
    mouthDimpleRight: 1,
  },
  crazy: {
    browInnerUp: 0.9,
    jawForward: 1,
    noseSneerLeft: 0.5700000000000001,
    noseSneerRight: 0.51,
    eyeLookDownLeft: 0.39435766259644545,
    eyeLookUpRight: 0.4039761421719682,
    eyeLookInLeft: 0.9618479575523053,
    eyeLookInRight: 0.9618479575523053,
    jawOpen: 0.9618479575523053,
    mouthDimpleLeft: 0.9618479575523053,
    mouthDimpleRight: 0.9618479575523053,
    mouthStretchLeft: 0.27893590769016857,
    mouthStretchRight: 0.2885543872656917,
    mouthSmileLeft: 0.5578718153803371,
    mouthSmileRight: 0.38473918302092225,
    tongueOut: 0.9618479575523053,
  },
};

// âŒ Ø§ÛŒÙ† Ø¢Ø¨Ø¬Ú©Øª Ú†ÙˆÙ† Ø§Ø³ØªÙØ§Ø¯Ù‡ Ù†Ù…ÛŒâ€ŒØ´ÙˆØ¯ Ùˆ Ø¯Ø§Ø±Ø§ÛŒ ÙˆØ±ÙˆØ¯ÛŒ ØªÚ©Ø±Ø§Ø±ÛŒ Ø§Ø³Øª Ø­Ø°Ù Ù…ÛŒâ€ŒØ´ÙˆØ¯.
// const corresponding = {
//   A: "viseme_PP",
//   B: "viseme_kk",
//   C: "viseme_I",
//   D: "viseme_aa",
//   E: "viseme_O",
//   F: "viseme_U",
//   G: "viseme_FF",
//   H: "viseme_TH",
//   X: "viseme_PP",
//   F: "viseme_E",
//   U: "viseme_U",
// };

let setupMode = false;

export function Avatar({ ...props }) {
  const { nodes, materials, scene } = useGLTF(
    "/models/rhynoavatar2.glb"
  );

  const {
    isGenerating: loading,
    chatMessages,
    handleSendMessage,
    isSpeechPlaying,
    modelVolume,
    audioCurrentTime
  } = useContext(ChatbotUIContext);


  const [mouthCues, setMouthCues] = useState(null);



  const { animations } = useGLTF("/models/c2.glb");

  const [isFading, setIsFading] = useState(false);
  const [customAnimationUrl, setCustomAnimationUrl] = useState("");

  const group = useRef();
  const { actions, mixer } = useAnimations(animations, group);
  const previousAction = useRef(null);
  const timeoutRef = useRef([]);
  const searchIntervalRef = useRef(null);
  const [thinkingCounter, setThinkingCounter] = useState(0);
  // const [animation, setAnimation] = useState("idle"); // Ø§Ù†ÛŒÙ…ÛŒØ´Ù† Ù¾ÛŒØ´â€ŒÙØ±Ø¶

  const [animation, setAnimation] = useState(
    animations.find((a) => a.name === "idle") ? "idle" : animations[0].name // Check if Idle animation exists otherwise use first animation
  );
  const handleThinkingAnimation = useCallback(() => {
    const currentAction = actions["thinking"];
    if (!currentAction) return;

    setThinkingCounter(1); // ØªÙ†Ø¸ÛŒÙ… Ø´Ù…Ø§Ø±Ù†Ø¯Ù‡ Ø¨Ù‡ 1 Ø¨Ø±Ø§ÛŒ Ø§Ø¬Ø±Ø§ÛŒ Ø§ÙˆÙ„ÛŒÙ† Ø§Ù†ÛŒÙ…ÛŒØ´Ù†

    // Ø§Ø¬Ø±Ø§ÛŒ Ø§Ù†ÛŒÙ…ÛŒØ´Ù† thinking Ø¨Ø±Ø§ÛŒ Ø§ÙˆÙ„ÛŒÙ† Ø¨Ø§Ø±
    currentAction.reset().fadeIn(0.5).setLoop(THREE.LoopRepeat).play();

    timeoutRef.current.push(
      setTimeout(() => {
        // Ø§ÙØ²Ø§ÛŒØ´ Ø´Ù…Ø§Ø±Ù†Ø¯Ù‡ Ùˆ Ø§Ø¬Ø±Ø§ÛŒ Ø¯ÙˆØ¨Ø§Ø±Ù‡ Ø§Ù†ÛŒÙ…ÛŒØ´Ù† thinking
        setThinkingCounter(2); // ØªÙ†Ø¸ÛŒÙ… Ø´Ù…Ø§Ø±Ù†Ø¯Ù‡ Ø¨Ù‡ 2 Ø¨Ø±Ø§ÛŒ Ø§Ø¬Ø±Ø§ÛŒ Ø¯ÙˆÙ…ÛŒÙ† Ø§Ù†ÛŒÙ…ÛŒØ´Ù†
        setAnimation("thinking"); // ØªÙ†Ø¸ÛŒÙ… Ø§Ù†ÛŒÙ…ÛŒØ´Ù† Ø¨Ù‡ thinking Ø¨Ø±Ø§ÛŒ Ø§Ø¬Ø±Ø§ÛŒ Ø¯ÙˆÙ…

        timeoutRef.current.push(
          setTimeout(() => {
            setAnimation("idle"); // Ù¾Ø³ Ø§Ø² Ø¯Ùˆ Ø¨Ø§Ø± Ø§Ø¬Ø±Ø§ÛŒ thinking Ø¨Ù‡ idle Ø¨Ø±Ú¯Ø±Ø¯Ø¯
          }, currentAction._clip.duration * 1000)
        );
      }, currentAction._clip.duration * 1000)
    );
  }, [actions]);


  // Ø§ØµÙ„Ø§Ø­ ØªØ§Ø¨Ø¹ handleAnimationEnd
  const handleAnimationEnd = useCallback(
    (action, animationType) => {
      clearAllTimeouts(); // Ù¾Ø§Ú©Ø³Ø§Ø²ÛŒ ØªÙ…Ø§Ù…ÛŒ ØªØ§ÛŒÙ…Ø±Ù‡Ø§

      // Ù…Ø¯ÛŒØ±ÛŒØª Ø§Ù†ÛŒÙ…ÛŒØ´Ù† hello: ÛŒÚ© Ø¨Ø§Ø± Ø§Ø¬Ø±Ø§ Ùˆ Ø³Ù¾Ø³ ØªØºÛŒÛŒØ± Ø¨Ù‡ idle
      if (animationType === "hello") {
        // Ø§Ú¯Ø± Ø§Ù†ÛŒÙ…ÛŒØ´Ù† hello Ø§Ø¬Ø±Ø§ Ø´Ø¯Ù‡ØŒ Ø¨Ù‡ idle ØªØºÛŒÛŒØ± Ú©Ù†Ø¯
        action.setLoop(THREE.LoopOnce);
        setAnimation("idle"); // ØªÙ†Ø¸ÛŒÙ… Ø§Ù†ÛŒÙ…ÛŒØ´Ù† Ø¨Ù‡ idle Ù¾Ø³ Ø§Ø² Ù¾Ø§ÛŒØ§Ù† hello
      }

      // Ù…Ø¯ÛŒØ±ÛŒØª Ø§Ù†ÛŒÙ…ÛŒØ´Ù† thinking: Ø¯ÙˆØ¨Ø§Ø± Ø§Ø¬Ø±Ø§ Ùˆ Ø³Ù¾Ø³ ØªØºÛŒÛŒØ± Ø¨Ù‡ idle
      else if (animationType === "thinking") {
        if (thinkingCounter < 2) {
          // Ø§ÙØ²Ø§ÛŒØ´ Ø´Ù…Ø§Ø±Ù†Ø¯Ù‡ Ùˆ Ø§Ø¬Ø±Ø§ÛŒ Ø¯ÙˆØ¨Ø§Ø±Ù‡ Ø§Ù†ÛŒÙ…ÛŒØ´Ù† thinking
          setThinkingCounter((prev) => prev + 1);
          setAnimation("thinking"); // ØªÙ†Ø¸ÛŒÙ… Ø¯ÙˆØ¨Ø§Ø±Ù‡ Ø§Ù†ÛŒÙ…ÛŒØ´Ù† thinking
        } else {
          // Ø´Ù…Ø§Ø±Ù†Ø¯Ù‡ Ø¨Ù‡ 2 Ø±Ø³ÛŒØ¯Ù‡ØŒ ØªØºÛŒÛŒØ± Ø¨Ù‡ Ø§Ù†ÛŒÙ…ÛŒØ´Ù† idle
          setThinkingCounter(0);
          setAnimation("idle");
        }
      }

      // Ù…Ø¯ÛŒØ±ÛŒØª Ø³Ø§ÛŒØ± Ø§Ù†ÛŒÙ…ÛŒØ´Ù†â€ŒÙ‡Ø§
      else if (animationType === "idle") {
        action.setLoop(THREE.LoopRepeat);
        action.play();
      }
    },
    [setAnimation, thinkingCounter]
  );


  // ØªØ§Ø¨Ø¹ Ú©Ù…Ú©ÛŒ Ø¨Ø±Ø§ÛŒ Ù¾Ø§Ú©Ø³Ø§Ø²ÛŒ ØªÙ…Ø§Ù… ØªØ§ÛŒÙ…Ø±Ù‡Ø§
  const clearAllTimeouts = () => {
    timeoutRef.current.forEach((timer) => clearTimeout(timer));
    timeoutRef.current = [];
  };

  // ØªØ§Ø¨Ø¹ Ú©Ù…Ú©ÛŒ Ø¨Ø±Ø§ÛŒ ØªØºÛŒÛŒØ± Ø¨Ù‡ Ø­Ø§Ù„Øª idle
  const switchToIdle = () => {
    setAnimation("idle");
    if (actions && actions["idle"]) {
      actions["idle"].setLoop(THREE.LoopRepeat);
      actions["idle"].play();
    }
  };

  const lerpMorphTarget = (target, value, speed = 0.1) => {
    scene.traverse((child) => {
      if (child.isSkinnedMesh && child.morphTargetDictionary) {
        const index = child.morphTargetDictionary[target];
        if (
          index === undefined ||
          child.morphTargetInfluences[index] === undefined
        ) {
          return;
        }
        child.morphTargetInfluences[index] = THREE.MathUtils.lerp(
          child.morphTargetInfluences[index],
          value,
          speed
        );

        if (!setupMode) {
          try {
            set({
              [target]: value,
            });
          } catch (e) { }
        }
      }
    });
  };

  const preservePosition = () => {
    group.current.children.forEach((child) => {
      if (child.isSkinnedMesh) {
        child.updateMatrixWorld(true);
      }
    });
  };

  const restorePosition = () => {
    group.current.children.forEach((child) => {
      if (child.isSkinnedMesh) {
        child.updateMatrixWorld(true);
      }
    });
  };
  // useEffect(() => {
  //   console.log("Received message:", message); // Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§ÛŒ Ù¾ÛŒØ§Ù… Ø±Ø§ Ù„Ø§Ú¯ Ú©Ù†ÛŒØ¯
  // }, [message]);

  useEffect(() => {
    if (!actions) {
      console.warn("Actions are not loaded yet.");
      return;
    }

    if (!animations || animations.length === 0) {
      console.warn("No animations found.");
      return;
    }

    // console.log("All animations loaded successfully:", animations);
  }, [actions, animations]);
  // rhyno/components/chat/Avatar.jsx

  // useRef Ø¨Ø±Ø§ÛŒ Ù¾ÛŒÚ¯ÛŒØ±ÛŒ Ø§ÛŒÙ†Ú©Ù‡ Ø¢ÛŒØ§ Ù¾ÛŒØ§Ù… Ù‚Ø¨Ù„ÛŒ Ù¾Ø±Ø¯Ø§Ø²Ø´ Ø´Ø¯Ù‡ Ø§Ø³Øª
  const lastMessageCount = useRef(0);

  useEffect(() => {
    if (!actions) return; // Ø§Ú¯Ø± Ø§Ù†ÛŒÙ…ÛŒØ´Ù†â€ŒÙ‡Ø§ Ù„ÙˆØ¯ Ù†Ø´Ø¯Ù‡â€ŒØ§Ù†Ø¯ØŒ Ø®Ø§Ø±Ø¬ Ø´Ùˆ

    // 1. Ø§Ú¯Ø± Ù…Ø¯Ù„ Ø¯Ø± Ø­Ø§Ù„ "ÙÚ©Ø± Ú©Ø±Ø¯Ù†" (generating) Ø§Ø³Øª
    if (loading) {
      setAnimation("thinking");
      return; // Ø®Ø§Ø±Ø¬ Ø´Ùˆ
    }

    // 2. Ø§Ú¯Ø± Ù„ÙˆØ¯ÛŒÙ†Ú¯ ØªÙ…Ø§Ù… Ø´Ø¯Ù‡ Ùˆ Ù¾ÛŒØ§Ù… Ø¬Ø¯ÛŒØ¯ÛŒ Ø§Ø² "Ø¯Ø³ØªÛŒØ§Ø±" Ø¢Ù…Ø¯Ù‡
    if (!loading && chatMessages.length > lastMessageCount.current) {
      const lastMessage = chatMessages[chatMessages.length - 1];

      // Ø§Ú¯Ø± Ù¾ÛŒØ§Ù… Ø¢Ø®Ø± Ø§Ø² "Ø¯Ø³ØªÛŒØ§Ø±" Ø¨Ø§Ø´Ø¯ØŒ Ø§Ù†ÛŒÙ…ÛŒØ´Ù† "ØªÙˆØ¶ÛŒØ­ Ø¯Ø§Ø¯Ù†" Ø±Ø§ Ù¾Ø®Ø´ Ú©Ù†
      if (lastMessage.message.role === "assistant") {
        setAnimation("explain"); // ÛŒØ§ Ù‡Ø± Ø§Ù†ÛŒÙ…ÛŒØ´Ù†ÛŒ Ú©Ù‡ Ø¨Ø±Ø§ÛŒ ØµØ­Ø¨Øª Ú©Ø±Ø¯Ù† Ø¯Ø§Ø±ÛŒØ¯
      } else {
        // Ø§Ú¯Ø± Ù¾ÛŒØ§Ù… Ø¢Ø®Ø± Ø§Ø² Ú©Ø§Ø±Ø¨Ø± Ø¨ÙˆØ¯ (Ù…Ø«Ù„Ø§ Ø¨Ø¹Ø¯ Ø§Ø² ÙˆÛŒØ±Ø§ÛŒØ´)ØŒ Ø¨Ù‡ idle Ø¨Ø±Ú¯Ø±Ø¯
        setAnimation("idle");
      }
    }
    // 3. Ø§Ú¯Ø± Ù†Ù‡ Ù„ÙˆØ¯ÛŒÙ†Ú¯ Ø¨ÙˆØ¯ Ùˆ Ù†Ù‡ Ù¾ÛŒØ§Ù… Ø¬Ø¯ÛŒØ¯ÛŒ (Ø­Ø§Ù„Øª Ù¾ÛŒØ´â€ŒÙØ±Ø¶)
    else if (!loading) {
      setAnimation("idle");
    }

    // ØªØ¹Ø¯Ø§Ø¯ Ù¾ÛŒØ§Ù…â€ŒÙ‡Ø§ Ø±Ø§ Ø¨Ù‡â€ŒØ±ÙˆØ² Ù†Ú¯Ù‡ Ø¯Ø§Ø±
    lastMessageCount.current = chatMessages.length;

  }, [loading, chatMessages, actions]); // ÙˆØ§Ø¨Ø³ØªÚ¯ÛŒ Ø¨Ù‡ Ø§Ø³ØªÛŒØªâ€ŒÙ‡Ø§ÛŒ rhyno


  useEffect(() => {
    if (actions && animation && actions[animation]) {
      // console.log("Current animation:", animation); // Ú†Ø§Ù¾ Ù†Ø§Ù… Ø§Ù†ÛŒÙ…ÛŒØ´Ù† Ø¯Ø± Ø­Ø§Ù„ Ø§Ø¬Ø±Ø§

      const currentAction = actions[animation];
      const previous = previousAction.current;

      if (previous && previous !== currentAction) {
        previous.crossFadeTo(currentAction, 0.01, true);
        currentAction.setEffectiveWeight(1);
        currentAction.play();
      } else {
        currentAction.setEffectiveWeight(1);
        currentAction.play();
      }

      previousAction.current = currentAction;

      const onAnimationFinished = (event) => {
        if (event.action === currentAction) {
          handleAnimationEnd(currentAction, animation);
        }
      };

      currentAction._mixer.addEventListener("finished", onAnimationFinished);

      return () => {
        if (previous && typeof previous.stop === "function") {
          previous.stop();
        }
        currentAction._mixer.removeEventListener("finished", onAnimationFinished);
      };
    }
  }, [animation, actions, handleAnimationEnd]);


  useFrame(() => {
    if (animation) {
      // console.log("Currently playing animation:", animation); // Ù‡Ù…ÛŒØ´Ù‡ Ú†Ø§Ù¾ Ù†Ø§Ù… Ø§Ù†ÛŒÙ…ÛŒØ´Ù† Ø¯Ø± Ù‡Ø± ÙØ±ÛŒÙ…
    }
  });






  const [blink, setBlink] = useState(false);
  const [winkLeft, setWinkLeft] = useState(false);
  const [winkRight, setWinkRight] = useState(false);
  const [facialExpression, setFacialExpression] = useState("");
  const [audio, setAudio] = useState();


  useEffect(() => {
    if (mixer) {
      mixer.clipAction(animations[0]).setEffectiveWeight(1).syncWith(mixer.clipAction(animations[1]));
    }
  }, [animations, mixer]);



  useFrame(() => {
    if (!setupMode) {
      group.current.children.forEach((child) => {
        if (child.isSkinnedMesh && child.name.includes("Hand")) {
          // Ú©Ù†ØªØ±Ù„ Ø¯Ø³ØªÛŒ Ù…ÙˆÙ‚Ø¹ÛŒØª Ùˆ Ú†Ø±Ø®Ø´ Ø¯Ø³Øªâ€ŒÙ‡Ø§
          child.position.lerp(new THREE.Vector3(0, 0, 0), 0.1);
          child.quaternion.slerp(new THREE.Quaternion(0, 0, 0, 1), 0.1);
        }
      });
    }
  });

  useFrame(() => {
    group.current.children.forEach((child) => {
      if (child.isSkinnedMesh) {
        // Ø§ÛŒÙ† Ø¨Ø®Ø´ Ø¨Ø±Ø§ÛŒ Ú©Ù†ØªØ±Ù„ Ø¯Ø³ØªÛŒ Ú†Ø±Ø®Ø´ Ùˆ Ù…ÙˆÙ‚Ø¹ÛŒØª Ø§Ø³ØªØ®ÙˆØ§Ù†â€ŒÙ‡Ø§ Ø¯Ø± Ø§Ù†ÛŒÙ…ÛŒØ´Ù†â€ŒÙ‡Ø§
        child.rotation.x = THREE.MathUtils.lerp(child.rotation.x, 0, 0.1);
        child.rotation.y = THREE.MathUtils.lerp(child.rotation.y, 0, 0.1);
        child.rotation.z = THREE.MathUtils.lerp(child.rotation.z, 0, 0.1);
      }
    });
  });
  useFrame(() => {
    if (actions && actions["idle"]) {
      const idleAction = actions["idle"];
      idleAction.setEffectiveWeight(1); // ÙˆØ²Ù† Ø§Ù†ÛŒÙ…ÛŒØ´Ù† idle Ø±Ø§ Ø±ÙˆÛŒ 1 Ù‚Ø±Ø§Ø± Ø¯Ù‡ÛŒØ¯ ØªØ§ Ù‡Ù…ÙˆØ§Ø±Ù‡ ÙØ¹Ø§Ù„ Ø¨Ù…Ø§Ù†Ø¯
      idleAction.setEffectiveTimeScale(1);
    }

    // Ø§Ø¯Ø§Ù…Ù‡ Ú©Ø¯ Ù…Ø±Ø¨ÙˆØ· Ø¨Ù‡ lipsync Ùˆ Ø³Ø§ÛŒØ± Ø§Ù†ÛŒÙ…ÛŒØ´Ù†â€ŒÙ‡Ø§
  });
  useEffect(() => {
    // ÙØ§ÛŒÙ„ JSON Ø±Ø§ Ø§Ø² Ù¾ÙˆØ´Ù‡ public Ù…ÛŒâ€ŒØ®ÙˆØ§Ù†Ø¯
    fetch("/mouth-case.json")
      .then((response) => response.json())
      .then((data) => {
        // Ø¢Ø±Ø§ÛŒÙ‡ mouthCues Ø±Ø§ Ø§Ø² ÙØ§ÛŒÙ„ JSON Ø®ÙˆØ§Ù†Ø¯Ù‡ Ùˆ Ø¯Ø± state Ø°Ø®ÛŒØ±Ù‡ Ù…ÛŒâ€ŒÚ©Ù†Ø¯
        setMouthCues(data.mouthCues);
      })
      .catch((err) => console.error("Ø®Ø·Ø§ Ø¯Ø± Ø¨Ø§Ø±Ú¯Ø°Ø§Ø±ÛŒ mouth-case.json:", err));
  }, []);

  useFrame(() => {
    // --- Ù…Ø¯ÛŒØ±ÛŒØª Ø­Ø§Ù„Ø§Øª Ú†Ù‡Ø±Ù‡ (Facial Expressions) ---
    !setupMode &&
      Object.keys(nodes.EyeLeft.morphTargetDictionary).forEach((key) => {
        const mapping = facialExpressions[facialExpression];
        if (key === "eyeBlinkLeft" || key === "eyeBlinkRight") {
          return; 
        }
        if (mapping && mapping[key]) {
          lerpMorphTarget(key, mapping[key], 0.1);
        } else {
          lerpMorphTarget(key, 0, 0.1); 
        }
      });

    // Ø§Ø¹Ù…Ø§Ù„ Ø§Ù†ÛŒÙ…ÛŒØ´Ù† Ù¾Ù„Ú© Ø²Ø¯Ù† (Blinking/Winking)
    lerpMorphTarget("eyeBlinkLeft", blink || winkLeft ? 1 : 0, 0.5);
    lerpMorphTarget("eyeBlinkRight", blink || winkRight ? 1 : 0, 0.5);

    // --- ğŸ’¥ Ø§ØµÙ„Ø§Ø­ Ù†Ù‡Ø§ÛŒÛŒ Ù„ÛŒÙ¾â€ŒØ³ÛŒÙ†Ú©: Ø§Ø·Ù…ÛŒÙ†Ø§Ù† Ø§Ø² Ø­Ø±Ú©Øª ÙÚ© Ùˆ visemeÙ‡Ø§ ---
    if (setupMode) return;
console.log("Avatar.jsx - Incoming modelVolume:", modelVolume);
    // Ù…Ù‚ÛŒØ§Ø³â€ŒØ¯Ù‡ÛŒ ÙˆÙ„ÙˆÙ…: Ù…Ø·Ù…Ø¦Ù† Ø´ÙˆÛŒØ¯ Ú©Ù‡ Ø¹Ø¯Ø¯ Ø¨ÛŒÙ† 0 Ùˆ 1 Ø§Ø³Øª
    const normalizedVolume = THREE.MathUtils.clamp(modelVolume / 50, 0, 1); 

    let dynamicVolume = normalizedVolume;
    if (normalizedVolume > 0.01) {
      // Ø§ÙØ²ÙˆØ¯Ù† ÙØ§Ú©ØªÙˆØ± ØªØµØ§Ø¯ÙÛŒ Ú©ÙˆÚ†Ú© Ø¨Ø±Ø§ÛŒ Ø·Ø¨ÛŒØ¹ÛŒâ€ŒØªØ± Ø´Ø¯Ù† Ø­Ø±Ú©Øª
      const randomFactor = (Math.random() - 0.5) * 0.5; // Ø¨ÛŒÙ† -0.25 ØªØ§ +0.25
      dynamicVolume = THREE.MathUtils.clamp(normalizedVolume + randomFactor, 0, 1);
    }
console.log("Avatar.jsx - Calculated dynamicVolume:", dynamicVolume.toFixed(4));
    // Ø§Ú¯Ø± ÙˆÙ„ÙˆÙ… Ø®ÛŒÙ„ÛŒ Ú©Ù… Ø§Ø³ØªØŒ ØªÙ…Ø§Ù… Ù…ÙˆØ±Ùâ€ŒÙ‡Ø§ Ø±Ø§ Ø±ÛŒØ³Øª Ú©Ù†
    if (dynamicVolume < 0.01) {
        lerpMorphTarget("jawOpen", 0, 0.1);
        ["viseme_aa", "viseme_E", "viseme_O"].forEach(viseme => {
            lerpMorphTarget(viseme, 0, 0.1);
        });
        return; 
    }

    // Ù†Ù‚Ø´Ù‡ ØªØ£Ø«ÛŒØ±Ú¯Ø°Ø§Ø±ÛŒ Ù‚ÙˆÛŒ Ø¨Ø±Ø§ÛŒ Ù„ÛŒÙ¾â€ŒØ³ÛŒÙ†Ú© Ø¨Ø± Ø§Ø³Ø§Ø³ ÙˆÙ„ÙˆÙ…
    const volumeBasedVisemes = {
      "jawOpen": dynamicVolume * 0.7, // Ú©Ù†ØªØ±Ù„ Ù‚ÙˆÛŒ ÙÚ©
      "viseme_aa": dynamicVolume * 0.8, 
      "viseme_E": dynamicVolume * 0.6,  
      "viseme_O": dynamicVolume * 0.5,  
      "viseme_PP": dynamicVolume * 0.3, 
      "viseme_FF": dynamicVolume * 0.3, 
      "viseme_SS": dynamicVolume * 0.5,
    };
console.log("Avatar.jsx - Target jawOpen value:", volumeBasedVisemes["jawOpen"].toFixed(4));
    // Ù„ÛŒØ³Øª Ú©Ø§Ù…Ù„ morphTargetÙ‡Ø§ÛŒÛŒ Ú©Ù‡ Ù…ÛŒâ€ŒØ®ÙˆØ§Ù‡ÛŒÙ… Ú©Ù†ØªØ±Ù„ Ú©Ù†ÛŒÙ…
    const controlledMorphTargets = [
      ...Object.keys(volumeBasedVisemes), 
      "viseme_I", "viseme_kk", "viseme_U", "viseme_TH", "viseme_M", 
      "viseme_FV", "viseme_L", "viseme_R", "viseme_T", "viseme_D"
    ];

    // Ø§Ø¹Ù…Ø§Ù„ ØªØ£Ø«ÛŒØ±Ø§Øª: Ø§Ú¯Ø± Ø¯Ø± Ù†Ù‚Ø´Ù‡ Ø¨Ø§Ù„Ø§ Ø¨ÙˆØ¯ØŒ Ù…Ù‚Ø¯Ø§Ø±Ø´ Ø§Ø¹Ù…Ø§Ù„ Ø´ÙˆØ¯ØŒ Ø¯Ø± ØºÛŒØ± Ø§ÛŒÙ† ØµÙˆØ±Øª 0 Ø´ÙˆØ¯.
    controlledMorphTargets.forEach((key) => {
      const targetValue = volumeBasedVisemes[key] !== undefined 
          ? volumeBasedVisemes[key] 
          : 0;
        
      const speed = key === "jawOpen" ? 0.2 : 0.1; // Ø³Ø±Ø¹Øª Ø¢Ù‡Ø³ØªÙ‡â€ŒØªØ± Ø¨Ø±Ø§ÛŒ ÙÚ©
        
      lerpMorphTarget(key, targetValue, speed);
    });

  });

  // useControls... (Ø­Ø°Ù Ø´Ø¯Ù‡ Ø¨Ø±Ø§ÛŒ ÙˆØ¶ÙˆØ­)

  useEffect(() => {
    let blinkTimeout;
    const nextBlink = () => {
      blinkTimeout = setTimeout(() => {
        setBlink(true);
        setTimeout(() => {
          setBlink(false);
          nextBlink();
        }, 200);
      }, THREE.MathUtils.randInt(1000, 5000));
    };
    nextBlink();
    return () => clearTimeout(blinkTimeout);
  }, []);

  return (

    <group ref={group} {...props}>
      <primitive object={nodes.Hips} />
      <skinnedMesh
        name="EyeLeft"
        geometry={nodes.EyeLeft.geometry}
        material={materials.Wolf3D_Eye}
        skeleton={nodes.EyeLeft.skeleton}
        morphTargetDictionary={nodes.EyeLeft.morphTargetDictionary}
        morphTargetInfluences={nodes.EyeLeft.morphTargetInfluences}
      />
      <skinnedMesh
        name="EyeRight"
        geometry={nodes.EyeRight.geometry}
        material={materials.Wolf3D_Eye}
        skeleton={nodes.EyeRight.skeleton}
        morphTargetDictionary={nodes.EyeRight.morphTargetDictionary}
        morphTargetInfluences={nodes.EyeRight.morphTargetInfluences}
      />
      <skinnedMesh
        name="Wolf3D_Head"
        geometry={nodes.Wolf3D_Head.geometry}
        material={materials.Wolf3D_Skin}
        skeleton={nodes.Wolf3D_Head.skeleton}
        morphTargetDictionary={nodes.Wolf3D_Head.morphTargetDictionary}
        morphTargetInfluences={nodes.Wolf3D_Head.morphTargetInfluences}
      />
      <skinnedMesh
        name="Wolf3D_Teeth"
        geometry={nodes.Wolf3D_Teeth.geometry}
        material={materials.Wolf3D_Teeth}
        skeleton={nodes.Wolf3D_Teeth.skeleton}
        morphTargetDictionary={nodes.Wolf3D_Teeth.morphTargetDictionary}
        morphTargetInfluences={nodes.Wolf3D_Teeth.morphTargetInfluences}
      />
      <skinnedMesh
        geometry={nodes.Wolf3D_Hair.geometry}
        material={materials.Wolf3D_Hair}
        skeleton={nodes.Wolf3D_Hair.skeleton}
      />
      <skinnedMesh
        geometry={nodes.Wolf3D_Body.geometry}
        material={materials.Wolf3D_Body}
        skeleton={nodes.Wolf3D_Body.skeleton}
      />
      <skinnedMesh
        geometry={nodes.Wolf3D_Outfit_Bottom.geometry}
        material={materials.Wolf3D_Outfit_Bottom}
        skeleton={nodes.Wolf3D_Outfit_Bottom.skeleton}
      />
      <skinnedMesh
        geometry={nodes.Wolf3D_Outfit_Footwear.geometry}
        material={materials.Wolf3D_Outfit_Footwear}
        skeleton={nodes.Wolf3D_Outfit_Footwear.skeleton}
      />
      <skinnedMesh
        geometry={nodes.Wolf3D_Outfit_Top.geometry}
        material={materials.Wolf3D_Outfit_Top}
        skeleton={nodes.Wolf3D_Outfit_Top.skeleton}
      />
    </group>
  )
}


useGLTF.preload("/models/rhynoavatar2.glb");
useGLTF.preload("/models/c2.glb");