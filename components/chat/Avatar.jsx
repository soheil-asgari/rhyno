/*

Auto - generated by: https://github.com/pmndrs/gltfjsx
Command: npx gltfjsx @6.2.3 public / models / 64f1a714fe61576b46f27ca2.glb - o src / components / Avatar.jsx - k - r public
  */

import { useAnimations, useGLTF } from "@react-three/drei";
import { useFrame } from "@react-three/fiber";
import { button, useControls } from "leva";
import React, { useEffect, useRef, useState, useCallback, useContext, useMemo, } from "react"; // 1. useContext اینجاست
import * as THREE from "three";



import { ChatbotUIContext } from "@/context/context";


// همگام‌سازی موقعیت
const preserveBonePositions = () => {
  group.current.children.forEach((child) => {
    if (child.isSkinnedMesh && child.skeleton) {
      child.skeleton.bones.forEach((bone) => {
        bone.userData.previousPosition = bone.position.clone();
        bone.userData.previousQuaternion = bone.quaternion.clone();
      });
    }
  });
};

const restoreBonePositions = () => {
  group.current.children.forEach((child) => {
    if (child.isSkinnedMesh && child.skeleton) {
      child.skeleton.bones.forEach((bone) => {
        if (bone.userData.previousPosition && bone.userData.previousQuaternion) {
          bone.position.copy(bone.userData.previousPosition);
          bone.quaternion.copy(bone.userData.previousQuaternion);
        }
      });
    }
  });
};


const facialExpressions = {
  default: {},
  smile: {
    browInnerUp: 0.16999999650706504,
    mouthPressLeft: 0.61,
    mouthPressRight: 0.63,
    mouthSmileLeft: 0.2,
    mouthSmileRight: 0.2

  },
  funnyFace: {
    jawLeft: 0.63,
    mouthPucker: 0.53,
    noseSneerLeft: 1,
    noseSneerRight: 0.39,
    mouthLeft: 1,
    eyeLookUpLeft: 1,
    eyeLookUpRight: 1,
    cheekPuff: 0.9999924982764238,
    mouthDimpleLeft: 0.414743888682652,
    mouthRollLower: 0.32,
    mouthSmileLeft: 0.35499733688813034,
    mouthSmileRight: 0.35499733688813034,
  },
  sad: {
    mouthFrownLeft: 1,
    mouthFrownRight: 1,
    mouthShrugLower: 0.78341,
    browInnerUp: 0.452,
    eyeSquintLeft: 0.72,
    eyeSquintRight: 0.75,
    eyeLookDownLeft: 0.5,
    eyeLookDownRight: 0.5,
    jawForward: 1,
  },
  surprised: {
    eyeWideLeft: 0.5,
    eyeWideRight: 0.5,
    jawOpen: 0.351,
    mouthFunnel: 1,
    browInnerUp: 1,
  },
  angry: {
    browDownLeft: 1,
    browDownRight: 1,
    eyeSquintLeft: 1,
    eyeSquintRight: 1,
    jawForward: 1,
    jawLeft: 1,
    mouthShrugLower: 1,
    noseSneerLeft: 1,
    noseSneerRight: 0.42,
    eyeLookDownLeft: 0.16,
    eyeLookDownRight: 0.16,
    cheekSquintLeft: 1,
    cheekSquintRight: 1,
    mouthClose: 0.23,
    mouthFunnel: 0.63,
    mouthDimpleRight: 1,
  },
  crazy: {
    browInnerUp: 0.9,
    jawForward: 1,
    noseSneerLeft: 0.5700000000000001,
    noseSneerRight: 0.51,
    eyeLookDownLeft: 0.39435766259644545,
    eyeLookUpRight: 0.4039761421719682,
    eyeLookInLeft: 0.9618479575523053,
    eyeLookInRight: 0.9618479575523053,
    jawOpen: 0.9618479575523053,
    mouthDimpleLeft: 0.9618479575523053,
    mouthDimpleRight: 0.9618479575523053,
    mouthStretchLeft: 0.27893590769016857,
    mouthStretchRight: 0.2885543872656917,
    mouthSmileLeft: 0.5578718153803371,
    mouthSmileRight: 0.38473918302092225,
    tongueOut: 0.9618479575523053,
  },
};

const corresponding = {
  A: "viseme_PP",
  B: "viseme_kk",
  C: "viseme_I",
  D: "viseme_aa",
  E: "viseme_O",
  F: "viseme_U",
  G: "viseme_FF",
  H: "viseme_TH",
  X: "viseme_PP",
  F: "viseme_E",
  U: "viseme_U",
};

let setupMode = false;

export function Avatar({ ...props }) {
  const { nodes, materials, scene } = useGLTF(
    "/models/rhynoavatar2.glb"
  );

  const {
    isGenerating: loading,
    chatMessages,
    handleSendMessage,
    isSpeechPlaying,
    modelVolume,
    audioCurrentTime
  } = useContext(ChatbotUIContext);


  const [mouthCues, setMouthCues] = useState(null);



  const { animations } = useGLTF("/models/c2.glb");

  const [isFading, setIsFading] = useState(false);
  const [customAnimationUrl, setCustomAnimationUrl] = useState("");

  const group = useRef();
  const { actions, mixer } = useAnimations(animations, group);
  const previousAction = useRef(null);
  const timeoutRef = useRef([]);
  const searchIntervalRef = useRef(null);
  const [thinkingCounter, setThinkingCounter] = useState(0);
  // const [animation, setAnimation] = useState("idle"); // انیمیشن پیش‌فرض

  const [animation, setAnimation] = useState(
    animations.find((a) => a.name === "idle") ? "idle" : animations[0].name // Check if Idle animation exists otherwise use first animation
  );
  const handleThinkingAnimation = useCallback(() => {
    const currentAction = actions["thinking"];
    if (!currentAction) return;

    setThinkingCounter(1); // تنظیم شمارنده به 1 برای اجرای اولین انیمیشن

    // اجرای انیمیشن thinking برای اولین بار
    currentAction.reset().fadeIn(0.5).setLoop(THREE.LoopRepeat).play();

    timeoutRef.current.push(
      setTimeout(() => {
        // افزایش شمارنده و اجرای دوباره انیمیشن thinking
        setThinkingCounter(2); // تنظیم شمارنده به 2 برای اجرای دومین انیمیشن
        setAnimation("thinking"); // تنظیم انیمیشن به thinking برای اجرای دوم

        timeoutRef.current.push(
          setTimeout(() => {
            setAnimation("idle"); // پس از دو بار اجرای thinking به idle برگردد
          }, currentAction._clip.duration * 1000)
        );
      }, currentAction._clip.duration * 1000)
    );
  }, [actions]);


  // اصلاح تابع handleAnimationEnd
  const handleAnimationEnd = useCallback(
    (action, animationType) => {
      clearAllTimeouts(); // پاکسازی تمامی تایمرها

      // مدیریت انیمیشن hello: یک بار اجرا و سپس تغییر به idle
      if (animationType === "hello") {
        // اگر انیمیشن hello اجرا شده، به idle تغییر کند
        action.setLoop(THREE.LoopOnce);
        setAnimation("idle"); // تنظیم انیمیشن به idle پس از پایان hello
      }

      // مدیریت انیمیشن thinking: دوبار اجرا و سپس تغییر به idle
      else if (animationType === "thinking") {
        if (thinkingCounter < 2) {
          // افزایش شمارنده و اجرای دوباره انیمیشن thinking
          setThinkingCounter((prev) => prev + 1);
          setAnimation("thinking"); // تنظیم دوباره انیمیشن thinking
        } else {
          // شمارنده به 2 رسیده، تغییر به انیمیشن idle
          setThinkingCounter(0);
          setAnimation("idle");
        }
      }

      // مدیریت سایر انیمیشن‌ها
      else if (animationType === "idle") {
        action.setLoop(THREE.LoopRepeat);
        action.play();
      }
    },
    [setAnimation, thinkingCounter]
  );


  // تابع کمکی برای پاکسازی تمام تایمرها
  const clearAllTimeouts = () => {
    timeoutRef.current.forEach((timer) => clearTimeout(timer));
    timeoutRef.current = [];
  };

  // تابع کمکی برای تغییر به حالت idle
  const switchToIdle = () => {
    setAnimation("idle");
    if (actions && actions["idle"]) {
      actions["idle"].setLoop(THREE.LoopRepeat);
      actions["idle"].play();
    }
  };

  const lerpMorphTarget = (target, value, speed = 0.1) => {
    scene.traverse((child) => {
      if (child.isSkinnedMesh && child.morphTargetDictionary) {
        const index = child.morphTargetDictionary[target];
        if (
          index === undefined ||
          child.morphTargetInfluences[index] === undefined
        ) {
          return;
        }
        child.morphTargetInfluences[index] = THREE.MathUtils.lerp(
          child.morphTargetInfluences[index],
          value,
          speed
        );

        if (!setupMode) {
          try {
            set({
              [target]: value,
            });
          } catch (e) { }
        }
      }
    });
  };

  const preservePosition = () => {
    group.current.children.forEach((child) => {
      if (child.isSkinnedMesh) {
        child.updateMatrixWorld(true);
      }
    });
  };

  const restorePosition = () => {
    group.current.children.forEach((child) => {
      if (child.isSkinnedMesh) {
        child.updateMatrixWorld(true);
      }
    });
  };
  // useEffect(() => {
  //   console.log("Received message:", message); // داده‌های پیام را لاگ کنید
  // }, [message]);

  useEffect(() => {
    if (!actions) {
      console.warn("Actions are not loaded yet.");
      return;
    }

    if (!animations || animations.length === 0) {
      console.warn("No animations found.");
      return;
    }

    // console.log("All animations loaded successfully:", animations);
  }, [actions, animations]);
  // rhyno/components/chat/Avatar.jsx

  // useRef برای پیگیری اینکه آیا پیام قبلی پردازش شده است
  const lastMessageCount = useRef(0);

  useEffect(() => {
    if (!actions) return; // اگر انیمیشن‌ها لود نشده‌اند، خارج شو

    // 1. اگر مدل در حال "فکر کردن" (generating) است
    if (loading) {
      setAnimation("thinking");
      return; // خارج شو
    }

    // 2. اگر لودینگ تمام شده و پیام جدیدی از "دستیار" آمده
    if (!loading && chatMessages.length > lastMessageCount.current) {
      const lastMessage = chatMessages[chatMessages.length - 1];

      // اگر پیام آخر از "دستیار" باشد، انیمیشن "توضیح دادن" را پخش کن
      if (lastMessage.message.role === "assistant") {
        setAnimation("explain"); // یا هر انیمیشنی که برای صحبت کردن دارید
      } else {
        // اگر پیام آخر از کاربر بود (مثلا بعد از ویرایش)، به idle برگرد
        setAnimation("idle");
      }
    }
    // 3. اگر نه لودینگ بود و نه پیام جدیدی (حالت پیش‌فرض)
    else if (!loading) {
      setAnimation("idle");
    }

    // تعداد پیام‌ها را به‌روز نگه دار
    lastMessageCount.current = chatMessages.length;

  }, [loading, chatMessages, actions]); // وابستگی به استیت‌های rhyno


  useEffect(() => {
    if (actions && animation && actions[animation]) {
      // console.log("Current animation:", animation); // چاپ نام انیمیشن در حال اجرا

      const currentAction = actions[animation];
      const previous = previousAction.current;

      if (previous && previous !== currentAction) {
        previous.crossFadeTo(currentAction, 0.01, true);
        currentAction.setEffectiveWeight(1);
        currentAction.play();
      } else {
        currentAction.setEffectiveWeight(1);
        currentAction.play();
      }

      previousAction.current = currentAction;

      const onAnimationFinished = (event) => {
        if (event.action === currentAction) {
          handleAnimationEnd(currentAction, animation);
        }
      };

      currentAction._mixer.addEventListener("finished", onAnimationFinished);

      return () => {
        if (previous && typeof previous.stop === "function") {
          previous.stop();
        }
        currentAction._mixer.removeEventListener("finished", onAnimationFinished);
      };
    }
  }, [animation, actions, handleAnimationEnd]);


  useFrame(() => {
    if (animation) {
      // console.log("Currently playing animation:", animation); // همیشه چاپ نام انیمیشن در هر فریم
    }
  });






  const [blink, setBlink] = useState(false);
  const [winkLeft, setWinkLeft] = useState(false);
  const [winkRight, setWinkRight] = useState(false);
  const [facialExpression, setFacialExpression] = useState("");
  const [audio, setAudio] = useState();


  useEffect(() => {
    if (mixer) {
      mixer.clipAction(animations[0]).setEffectiveWeight(1).syncWith(mixer.clipAction(animations[1]));
    }
  }, [animations, mixer]);



  useFrame(() => {
    if (!setupMode) {
      group.current.children.forEach((child) => {
        if (child.isSkinnedMesh && child.name.includes("Hand")) {
          // کنترل دستی موقعیت و چرخش دست‌ها
          child.position.lerp(new THREE.Vector3(0, 0, 0), 0.1);
          child.quaternion.slerp(new THREE.Quaternion(0, 0, 0, 1), 0.1);
        }
      });
    }
  });

  useFrame(() => {
    group.current.children.forEach((child) => {
      if (child.isSkinnedMesh) {
        // این بخش برای کنترل دستی چرخش و موقعیت استخوان‌ها در انیمیشن‌ها
        child.rotation.x = THREE.MathUtils.lerp(child.rotation.x, 0, 0.1);
        child.rotation.y = THREE.MathUtils.lerp(child.rotation.y, 0, 0.1);
        child.rotation.z = THREE.MathUtils.lerp(child.rotation.z, 0, 0.1);
      }
    });
  });
  useFrame(() => {
    if (actions && actions["idle"]) {
      const idleAction = actions["idle"];
      idleAction.setEffectiveWeight(1); // وزن انیمیشن idle را روی 1 قرار دهید تا همواره فعال بماند
      idleAction.setEffectiveTimeScale(1);
    }

    // ادامه کد مربوط به lipsync و سایر انیمیشن‌ها
  });
  useEffect(() => {
    // فایل JSON را از پوشه public می‌خواند
    fetch("/mouth-case.json")
      .then((response) => response.json())
      .then((data) => {
        // آرایه mouthCues را از فایل JSON خوانده و در state ذخیره می‌کند
        setMouthCues(data.mouthCues);
      })
      .catch((err) => console.error("خطا در بارگذاری mouth-case.json:", err));
  }, []);

  useFrame(() => {
    // --- مدیریت حالات چهره (Facial Expressions) ---
    // این بخش حالات کلی چهره (مثل شادی، غم) را مدیریت می‌کند و ربطی به لیپ‌سینک ندارد
    !setupMode &&
      Object.keys(nodes.EyeLeft.morphTargetDictionary).forEach((key) => {
        const mapping = facialExpressions[facialExpression];
        if (key === "eyeBlinkLeft" || key === "eyeBlinkRight") {
          return; // پلک زدن در بخش بعدی جداگانه مدیریت می‌شود
        }
        if (mapping && mapping[key]) {
          lerpMorphTarget(key, mapping[key], 0.1);
        } else {
          lerpMorphTarget(key, 0, 0.1); // ریست کردن مورف‌های غیرفعال
        }
      });

    // اعمال انیمیشن پلک زدن (Blinking/Winking)
    lerpMorphTarget("eyeBlinkLeft", blink || winkLeft ? 1 : 0, 0.5);
    lerpMorphTarget("eyeBlinkRight", blink || winkRight ? 1 : 0, 0.5);

    // --- لیپ‌سینک ساده مبتنی بر ولوم صدا (Volume-Based Jaw Flap) ---
    if (setupMode) return;

    const scaledVolume = Math.min(modelVolume / 50, 10);

    // اگر صدا هست (ولوم > 0.01)، مقدار را کمی تصادفی کن تا لب طبیعی‌تر حرکت کند
    let dynamicVolume = scaledVolume;
    if (scaledVolume > 0.01) {
      const randomFactor = (Math.random() - 0.3) * 0.3; // بین -0.15 تا +0.15
      dynamicVolume = Math.max(0, Math.min(1, scaledVolume + randomFactor));
    }

    const activeVisemes1 = {
      "viseme_aa": dynamicVolume * 0.7,
      "viseme_O": dynamicVolume * 0.3,
      "viseme_I": dynamicVolume * 0.3,
      "viseme_PP": dynamicVolume * 0.2,
      "viseme_kk": dynamicVolume * 0.1,
      "viseme_U": dynamicVolume * 0.3,
      "viseme_FF": dynamicVolume * 0.1,
      "viseme_TH": dynamicVolume * 0.1,
      "viseme_SS": dynamicVolume * 0.5,
      "viseme_E": dynamicVolume * 0.5,
      "viseme_M": dynamicVolume * 0.1,
      "viseme_FV": dynamicVolume * 0.1,
      "viseme_L": dynamicVolume * 0.1,
      "viseme_R": dynamicVolume * 0.1,
      "viseme_T": dynamicVolume * 0.1,
      "viseme_D": dynamicVolume * 0.1,
    };
    function getRandomVisemes(dynamicVolume) {
      const keys = [
        "viseme_aa", "viseme_PP", "viseme_U"

      ];

      const activeVisemes = {};

      keys.forEach(key => {
        if (key === "viseme_aa") {
          // تاثیر بیشتر برای viseme_AA
          activeVisemes[key] = dynamicVolume * (Math.random() * (1 - 0.1) + 0.1);
        } else {
          activeVisemes[key] = dynamicVolume * (Math.random() * (0.5 - 0.1) + 0.1);
        }
      });

      return activeVisemes;
    }

    const activeVisemes = getRandomVisemes(dynamicVolume);
    const allVisemes = [...new Set(Object.values(corresponding))];
    // console.log(allVisemes);
    // console.log(activeVisemes);
    allVisemes.forEach((value) => {
      if (activeVisemes[value] !== undefined) {
        lerpMorphTarget(value, activeVisemes[value], 0.2);
      } else {
        lerpMorphTarget(value, 0, 0.1);
      }
    });
  });

  useControls("FacialExpressions", {
    winkLeft: button(() => {
      setWinkLeft(true);
      setTimeout(() => setWinkLeft(false), 300);
    }),
    winkRight: button(() => {
      setWinkRight(true);
      setTimeout(() => setWinkRight(false), 300);
    }),
    animation: {
      value: animation,
      options: animations.map((a) => a.name),
      onChange: (value) => setAnimation(value),
    },
    facialExpression: {
      options: Object.keys(facialExpressions),
      onChange: (value) => setFacialExpression(value),
    },
    enableSetupMode: button(() => {
      setupMode = true;
    }),
    disableSetupMode: button(() => {
      setupMode = false;
    }),
    logMorphTargetValues: button(() => {
      const emotionValues = {};
      Object.keys(nodes.EyeLeft.morphTargetDictionary).forEach((key) => {
        if (key === "eyeBlinkLeft" || key === "eyeBlinkRight") {
          return; // eyes wink/blink are handled separately
        }
        const value =
          nodes.EyeLeft.morphTargetInfluences[
          nodes.EyeLeft.morphTargetDictionary[key]
          ];
        if (value > 0.01) {
          emotionValues[key] = value;
        }
      });
      // console.log(JSON.stringify(emotionValues, null, 2));
    }),
  });

  const [, set] = useControls("MorphTarget", () =>
    Object.assign(
      {},
      ...Object.keys(nodes.EyeLeft.morphTargetDictionary).map((key) => {
        return {
          [key]: {
            label: key,
            value: 0,
            min: nodes.EyeLeft.morphTargetInfluences[
              nodes.EyeLeft.morphTargetDictionary[key]
            ],
            max: 1,
            onChange: (val) => {
              if (setupMode) {
                lerpMorphTarget(key, val, 1);
              }
            },
          },
        };
      })
    )
  );

  useEffect(() => {
    let blinkTimeout;
    const nextBlink = () => {
      blinkTimeout = setTimeout(() => {
        setBlink(true);
        setTimeout(() => {
          setBlink(false);
          nextBlink();
        }, 200);
      }, THREE.MathUtils.randInt(1000, 5000));
    };
    nextBlink();
    return () => clearTimeout(blinkTimeout);
  }, []);

  return (

    <group ref={group} {...props}>
      <primitive object={nodes.Hips} />
      <skinnedMesh
        name="EyeLeft"
        geometry={nodes.EyeLeft.geometry}
        material={materials.Wolf3D_Eye}
        skeleton={nodes.EyeLeft.skeleton}
        morphTargetDictionary={nodes.EyeLeft.morphTargetDictionary}
        morphTargetInfluences={nodes.EyeLeft.morphTargetInfluences}
      />
      <skinnedMesh
        name="EyeRight"
        geometry={nodes.EyeRight.geometry}
        material={materials.Wolf3D_Eye}
        skeleton={nodes.EyeRight.skeleton}
        morphTargetDictionary={nodes.EyeRight.morphTargetDictionary}
        morphTargetInfluences={nodes.EyeRight.morphTargetInfluences}
      />
      <skinnedMesh
        name="Wolf3D_Head"
        geometry={nodes.Wolf3D_Head.geometry}
        material={materials.Wolf3D_Skin}
        skeleton={nodes.Wolf3D_Head.skeleton}
        morphTargetDictionary={nodes.Wolf3D_Head.morphTargetDictionary}
        morphTargetInfluences={nodes.Wolf3D_Head.morphTargetInfluences}
      />
      <skinnedMesh
        name="Wolf3D_Teeth"
        geometry={nodes.Wolf3D_Teeth.geometry}
        material={materials.Wolf3D_Teeth}
        skeleton={nodes.Wolf3D_Teeth.skeleton}
        morphTargetDictionary={nodes.Wolf3D_Teeth.morphTargetDictionary}
        morphTargetInfluences={nodes.Wolf3D_Teeth.morphTargetInfluences}
      />
      <skinnedMesh
        geometry={nodes.Wolf3D_Hair.geometry}
        material={materials.Wolf3D_Hair}
        skeleton={nodes.Wolf3D_Hair.skeleton}
      />
      <skinnedMesh
        geometry={nodes.Wolf3D_Body.geometry}
        material={materials.Wolf3D_Body}
        skeleton={nodes.Wolf3D_Body.skeleton}
      />
      <skinnedMesh
        geometry={nodes.Wolf3D_Outfit_Bottom.geometry}
        material={materials.Wolf3D_Outfit_Bottom}
        skeleton={nodes.Wolf3D_Outfit_Bottom.skeleton}
      />
      <skinnedMesh
        geometry={nodes.Wolf3D_Outfit_Footwear.geometry}
        material={materials.Wolf3D_Outfit_Footwear}
        skeleton={nodes.Wolf3D_Outfit_Footwear.skeleton}
      />
      <skinnedMesh
        geometry={nodes.Wolf3D_Outfit_Top.geometry}
        material={materials.Wolf3D_Outfit_Top}
        skeleton={nodes.Wolf3D_Outfit_Top.skeleton}
      />
    </group>
  )
}


useGLTF.preload("/models/rhynoavatar2.glb");
useGLTF.preload("/models/c2.glb");